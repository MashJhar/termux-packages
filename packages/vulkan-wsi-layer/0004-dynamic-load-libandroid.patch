From e487fb9a110132781ac64aaaba5ebd0b3e79fc1b Mon Sep 17 00:00:00 2001
From: xMeM <haooy@outlook.com>
Date: Sat, 30 Mar 2024 21:11:14 +0800
Subject: [PATCH] dynamically load libandroid.so

---
 CMakeLists.txt        |   5 +-
 wsi/x11/swapchain.cpp | 170 ++++++++++++++++++++++++++----------------
 2 files changed, 107 insertions(+), 68 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2f5e4e1..aec8e12 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -186,6 +186,8 @@ endif()
 
 # X11 WSI
 if(BUILD_WSI_X11)
+   set(CMAKE_BUILD_TYPE "Debug")
+
    add_library(wsi_x11 STATIC
       wsi/x11/surface_properties.cpp
       wsi/x11/surface.cpp
@@ -197,8 +199,7 @@ if(BUILD_WSI_X11)
       ${CMAKE_CURRENT_BINARY_DIR})
 
    target_compile_options(wsi_x11 INTERFACE "-DBUILD_WSI_X11=1")
-   target_compile_options(wsi_x11 PUBLIC "--target=linux-aarch64-android33")
-   list(APPEND LINK_WSI_LIBS wsi_x11 xcb xcb-present xcb-xfixes xcb-dri3 android)
+   list(APPEND LINK_WSI_LIBS wsi_x11 xcb xcb-present xcb-xfixes xcb-dri3)
 else()
    list(APPEND JSON_COMMANDS COMMAND sed -i '/VK_KHR_xcb_surface/d' ${CMAKE_CURRENT_BINARY_DIR}/VkLayer_window_system_integration.json)
 endif()
diff --git a/wsi/x11/swapchain.cpp b/wsi/x11/swapchain.cpp
index bbbcf19..98c4413 100644
--- a/wsi/x11/swapchain.cpp
+++ b/wsi/x11/swapchain.cpp
@@ -34,6 +34,9 @@
 #include <cstdlib>
 #include <ctime>
 
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <stdexcept>
 #include <unistd.h>
 #include <util/timed_semaphore.hpp>
 #include <vulkan/vulkan_core.h>
@@ -54,29 +57,6 @@ namespace wsi
 namespace x11
 {
 
-struct image_data
-{
-   /* Device memory backing the image. */
-   VkDeviceMemory memory{};
-   VkSubresourceLayout layout;
-   void *map;
-
-   AHardwareBuffer *ahb;
-   xcb_pixmap_t pixmap;
-   uint64_t serial;
-   int dma_buf_fd;
-   fence_sync present_fence;
-
-   image_data()
-      : map(nullptr)
-      , ahb(nullptr)
-      , pixmap(0)
-      , serial(0)
-      , dma_buf_fd(-1)
-   {
-   }
-};
-
 typedef struct native_handle
 {
    int version; /* sizeof(native_handle_t) */
@@ -92,28 +72,83 @@ typedef struct native_handle
 #endif
 } native_handle_t;
 
-extern "C" const native_handle_t *AHardwareBuffer_getNativeHandle(const AHardwareBuffer *buffer);
-
-static int AHardwareBuffer_getDMABUF(AHardwareBuffer *AHwB)
+struct external_memory_android
 {
-   const native_handle_t *native_handle = AHardwareBuffer_getNativeHandle(AHwB);
-   if (native_handle)
+   external_memory_android(AHardwareBuffer *ahwb)
+      : m_ahwb(ahwb)
+   {
+      m_libandroid_handle = dlopen("libandroid.so", RTLD_NOW);
+      if (!m_libandroid_handle)
+      {
+         throw std::runtime_error(dlerror());
+      }
+
+#define LOAD_SYMBOL(name)                                                            \
+   if ((pfn##name = (typeof pfn##name)dlsym(m_libandroid_handle, #name)) == nullptr) \
+   {                                                                                 \
+      throw std::runtime_error(dlerror());                                           \
+   }
+
+      LOAD_SYMBOL(AHardwareBuffer_release)
+      LOAD_SYMBOL(AHardwareBuffer_describe)
+      LOAD_SYMBOL(AHardwareBuffer_getNativeHandle)
+#undef LOAD_SYMBOL
+   }
+
+   ~external_memory_android()
    {
-      AHardwareBuffer_Desc desc;
-      AHardwareBuffer_describe(AHwB, &desc);
-      const int *handle_fds = &native_handle->data[0];
-      const int num_fds = native_handle->numFds;
+      pfnAHardwareBuffer_release(m_ahwb);
+      dlclose(m_libandroid_handle);
+   }
 
-      for (int i = 0; i < num_fds; i++)
+   int dupfd()
+   {
+      const native_handle_t *native_handle = pfnAHardwareBuffer_getNativeHandle(m_ahwb);
+      if (native_handle)
       {
-         if (lseek(handle_fds[i], 0, SEEK_END) < desc.stride * desc.height * 4)
-            continue;
+         AHardwareBuffer_Desc desc;
+         pfnAHardwareBuffer_describe(m_ahwb, &desc);
+         const int *handle_fds = &native_handle->data[0];
+         const int num_fds = native_handle->numFds;
+
+         for (int i = 0; i < num_fds; i++)
+         {
+            if (lseek(handle_fds[i], 0, SEEK_END) < desc.stride * desc.height * 4)
+               continue;
 
-         return dup(handle_fds[i]);
+            return fcntl(handle_fds[i], F_DUPFD_CLOEXEC, 0);
+         }
       }
+
+      return -1;
    }
-   return -1;
-}
+
+private:
+   void *m_libandroid_handle;
+   AHardwareBuffer *m_ahwb;
+   void (*pfnAHardwareBuffer_describe)(const AHardwareBuffer *buffer, AHardwareBuffer_Desc *outDesc);
+   void (*pfnAHardwareBuffer_release)(AHardwareBuffer *buffer);
+   const native_handle_t *(*pfnAHardwareBuffer_getNativeHandle)(const AHardwareBuffer *buffer);
+};
+
+struct image_data
+{
+   /* Device memory backing the image. */
+   VkDeviceMemory memory{};
+   VkSubresourceLayout layout;
+   void *map;
+
+   xcb_pixmap_t pixmap;
+   uint64_t serial;
+   fence_sync present_fence;
+
+   image_data()
+      : map(nullptr)
+      , pixmap(0)
+      , serial(0)
+   {
+   }
+};
 
 swapchain::swapchain(layer::device_private_data &dev_data, const VkAllocationCallbacks *pAllocator, surface *surface)
    : wsi::swapchain_base(dev_data, pAllocator)
@@ -246,37 +281,44 @@ VkResult swapchain::create_and_bind_swapchain_image(VkImageCreateInfo image_crea
    subres.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    m_device_data.disp.GetImageSubresourceLayout(m_device, image.image, &subres, &data->layout);
 
-   if (has_dri3 && has_present)
+   if (!sw_wsi)
    {
-      VkMemoryGetAndroidHardwareBufferInfoANDROID get_ahb_info;
-      get_ahb_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
-      get_ahb_info.pNext = nullptr;
-      get_ahb_info.memory = data->memory;
-
-      res = m_device_data.disp.GetMemoryAndroidHardwareBufferANDROID(m_device, &get_ahb_info, &data->ahb);
-      if (res != VK_SUCCESS)
+      try
       {
-         WSI_LOG_ERROR("vkGetMemoryAndroidHardwareBufferANDROID failed:%d", res);
-         sw_wsi = true;
-      }
+         AHardwareBuffer *ahwb;
 
-      if ((data->dma_buf_fd = AHardwareBuffer_getDMABUF(data->ahb)) < 0)
-      {
-         WSI_LOG_ERROR("Cannot get dmabuf, disable DRI3");
-         sw_wsi = true;
-      }
-      data->pixmap = xcb_generate_id(m_connection);
+         VkMemoryGetAndroidHardwareBufferInfoANDROID get_ahb_info;
+         get_ahb_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
+         get_ahb_info.pNext = nullptr;
+         get_ahb_info.memory = data->memory;
+
+         res = m_device_data.disp.GetMemoryAndroidHardwareBufferANDROID(m_device, &get_ahb_info, &ahwb);
+         if (res != VK_SUCCESS)
+         {
+            throw std::runtime_error("vkGetMemoryAndroidHardwareBufferANDROID failed");
+         }
+
+         int fd = external_memory_android(ahwb).dupfd();
 
-      auto cookie = xcb_dri3_pixmap_from_buffers_checked(
-         m_connection, data->pixmap, m_window, 1, m_image_create_info.extent.width, m_image_create_info.extent.height,
-         data->layout.rowPitch, data->layout.offset, 0, 0, 0, 0, 0, 0, 24, 32, 1274, &data->dma_buf_fd);
+         data->pixmap = xcb_generate_id(m_connection);
 
-      auto err = xcb_request_check(m_connection, cookie);
-      if (err)
+         auto cookie = xcb_dri3_pixmap_from_buffers_checked(m_connection, data->pixmap, m_window, 1,
+                                                            m_image_create_info.extent.width,
+                                                            m_image_create_info.extent.height, data->layout.rowPitch,
+                                                            data->layout.offset, 0, 0, 0, 0, 0, 0, 24, 32, 1274, &fd);
+
+         auto err = xcb_request_check(m_connection, cookie);
+         if (err)
+         {
+            free(err);
+            throw std::runtime_error("xcb_dri3_pixmap_from_buffers failed");
+         }
+      }
+      catch (const std::exception &e)
       {
-         WSI_LOG_ERROR("xcb_dri3_pixmap_from_buffers failed:%d", err->error_code);
+         WSI_LOG_ERROR("%s", e.what());
+         WSI_LOG_ERROR("DRI3 is not available, falling back to sw WSI");
          sw_wsi = true;
-         free(err);
       }
    }
 
@@ -432,10 +474,6 @@ void swapchain::destroy_image(wsi::swapchain_image &image)
          m_device_data.disp.FreeMemory(m_device, data->memory, get_allocation_callbacks());
          data->memory = VK_NULL_HANDLE;
       }
-      if (data->ahb != nullptr)
-      {
-         AHardwareBuffer_release(data->ahb);
-      }
       if (!sw_wsi)
       {
          xcb_free_pixmap(m_connection, data->pixmap);
